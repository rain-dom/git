### 标识符

所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始

### 修饰符

- 访问控制修饰符 : default, public , protected, private
- 非访问控制修饰符 : final, abstract, static, synchronized

### 



### 枚举

枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。



## 对象和类

### 对象

- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
- **成员（实例）变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
- **类变量**：类变量也声明在类中，方法体之外，但必须声明为 static 类型。



### 构造方法：

创建对象的时候默认会调用构造方法来创建对象，（在堆中开辟空间），可以完成成员变量的某些初始化操作

构造方法的 语法：

方法名称：构造方法的方法名称必须跟类的名称保持一致

访问修饰符：后面讲

形参：可以用户自定义添加，跟方法的普通参数一样

方法体：完成对象的初始化功能

返回值：没有返回值

注意：

1、创建完类之后，如果没有手动调用构造方法，会有一个默认的无参的构造方法供调用

2、当用户自定义了构造方法之后，默认的无参构造方法就不能够使用了，必须要手动定义无参构造方法

3、同一个类中可以包含多个同名的构造方法



### 源文件声明规则

- 一个源文件中只能有一个 public 类
- 一个源文件可以有多个非 public 类
- 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。
- 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。
- 如果源文件包含 import 语句，那么应该放在 package 语句和类定义**之间**。如果没有 package 语句，那么 import 语句应该在源文件中最前面。
- import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。



## 基本数据类型

### 基本类型

六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。

Java的八种基本类型：（按字节来分）

boolean  布尔型  1个字节 8bit（8位）

byte   字节类型  1个字节			-128~127 

char   字符类型  2个字节

short   短整型   2个字节			-32768~32767

int     整型    4个字节					2^31~2^31 - 1

float   浮点型（单精度）4个字节

long   长整型   8个字节

double  双精度类型 8个字节

Java中默认的整数类型是int，如果要定义为long ，则要在数值后加上L或者l

默认的浮点型是双精度浮点，如果要定义float，则要在数值后面加上f或者F

一个字节等于8位，1个字节等于256个数。2^8

一个英文字母或者阿拉伯数字占一个字节

一个汉字占2个字节





char 没有负值，占两个字节，所以取值范围是 **0~2^16-1（65535）**。

### 引用类型

- 对象、数组都是引用数据类型。
- 所有引用类型的默认值都是null。



### Java常量

常量在程序运行时是不能被修改的。

在 Java 中使用 final 关键字来修饰常量



![字符数据类型](E:\deng\image\字符数据类型.png)

### 自动类型转换

* 转换从低级到高级。

* 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。

```
低  ------------------------------------>  高

byte,short,char—> int —> long—> float —> double 
```



## 变量类型



### 局部变量

- 局部变量声明在方法、构造方法或者语句块中；
- 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
- 访问修饰符不能用于局部变量；
- 局部变量只在声明它的方法、构造方法或者语句块中可见；
- 局部变量是在**栈**上分配的。
- 局部变量没有默认值，所以局部变量被声明后，**必须经过初始化**，才可以使用。



### 实例变量

- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；
- 当一个对象被实例化之后，每个实例变量的值就跟着确定；
- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；
- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；
- 实例变量可以声明在使用前或者使用后；
- 访问修饰符可以修饰实例变量；
- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
- 实例变量具有**默认值**。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；
- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。

### 类变量（静态变量）

- 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。
- 无论一个类创建了多少个对象，类只拥有类变量的**一份**拷贝。
- 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。
- 静态变量储存在**静态存储区**。经常被声明为常量，很少单独使用static声明变量。
- 静态变量在第一次被访问时创建，在程序结束时销毁。
- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。
- 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。
- 静态变量可以通过：*ClassName.VariableName*的方式访问。
- 类变量被声明为public static final类型时，类变量名称一般建议使用**大写字母**。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。



## Java 修饰符

### *访问控制修饰符

* private、protected不能修饰类
* 声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。
* **子类与基类不在同一包中**：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。
* *如果我们只想让该方法对其所在类的子类可见，则将该方法声明为 protected。

![访问修饰符](E:\deng\image\访问修饰符.png)



### 非访问修饰符

#### static 修饰符

- **静态变量：**

  无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。

- **静态方法：**

  static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。

#### final 修饰符

父类中的 final 方法可以被子类继承，但是不能被子类重写。

final 类不能被继承，没有类能够继承 final 类的任何特性。

#### abstract 修饰符

抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。

抽象类可以包含抽象方法和非抽象方法。

任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。

抽象方法的声明以分号结尾，例如：**public abstract sample();**。

#### synchronized 修饰符

#### transient 修饰符

序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。



## Java 运算符



### 位运算符

| 操作符 | 描述                                                         | 例子                           |
| :----- | :----------------------------------------------------------- | :----------------------------- |
| ＆     | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |
| \|     | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011 1101 |
| ^      | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |
| 〜     | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         | （〜A）得到-61，即1100 0011    |
| <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |
| >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |
| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 |                                |

### 条件运算符（?:）

// 如果 a 等于 1 成立，则设置 b 为 20，否则为 30      

b = (a == 1) ? 20 : 30;

### instanceof 运算符

如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。

```java
String name = "James";
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
```



## 循环结构

#### continue

让程序立刻跳转到下一次循环的迭代。



#### switch

如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出。





## 数组-Arrays

用来存储固定大小的**同类型**元素。

dataType[] arrayRefVar; 

引用数据类型



toString——打印数组

equals——比较数组是否相同

sort——数组排序	Arrays.sort(a);

binarySearch——二分查找



*  数组的某个元素被传递给一个方法并被该方法修改，当被调用方法执行完毕时，这个元素中含有修改过的数值。
*  看数组内是否有控制台输入的内容时需要加个flag，等加强for循环遍历完成后根据flag值判断

### For-Each 循环

```java
for(type element: array)
{
    System.out.println(element);
}
```



## *正则



## StringBuffer 

StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。

在所有的情况下选择使用 **stringbuiler**，除非你真的遇到了一个需要线程安全的场景.

 stringbuffer 的线程安全，仅仅是保证 jvm 不抛出异常顺利的往下执行而已，它可不保证逻辑正确和调用顺序正确。

## Java 日期时间



```java
DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

//将Date类按照规范转换为字符串格式
String str = dateFormat.format(date);
System.out.println(str);

//将字符串转换成对应的日期类
Date d1 = dateFormat.parse("2010-10-10 20:20:20");
System.out.println(d1);

//将字符串转换成对应的日期类
Date d1 = dateFormat.parse("2010-10-10 20:20:20");
System.out.println(d1);

//获取的是当前系统的时间
Calendar calendar = Calendar.getInstance();
System.out.println(calendar);
```

### 日期和时间的格式化编码

时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下：

| **字母** | **描述**                 | **示例**                |
| :------- | :----------------------- | :---------------------- |
| G        | 纪元标记                 | AD                      |
| y        | 四位年份                 | 2001                    |
| M        | 月份                     | July or 07              |
| d        | 一个月的日期             | 10                      |
| h        | A.M./P.M. (1~12)格式小时 | 12                      |
| H        | 一天中的小时 (0~23)      | 22                      |
| m        | 分钟数                   | 30                      |
| s        | 秒数                     | 55                      |
| S        | 毫秒数                   | 234                     |
| E        | 星期几                   | Tuesday                 |
| D        | 一年中的日子             | 360                     |
| F        | 一个月中第几周的周几     | 2 (second Wed. in July) |
| w        | 一年中第几周             | 40                      |
| W        | 一个月中第几周           | 1                       |
| a        | A.M./P.M. 标记           | PM                      |
| k        | 一天中的小时(1~24)       | 24                      |
| K        | A.M./P.M. (0~11)格式小时 | 10                      |
| z        | 时区                     | Eastern Standard Time   |
| '        | 文字定界符               | Delimiter               |
| "        | 单引号                   | `                       |

###### 

使用print格式化日期

测量时间

### Calender类对象字段类型



## 方法

### 方法的重载

两个方法拥有相同的名字，但是有不同的参数列表。

重载的方法必须拥有不同的参数列表。

### 变量作用域

### 可变参数

一个函数至多只能有一个可变参数，且可变参数为最后一个参数。

public static void printMax( double... numbers) { 实现逻辑}





































# ================









### 重载

---

：在一个类中可以包含多个重名的方法，但是注意方法的参数列表不能相		同

三个方面的不同：

参数的个数不同

参数的类型不同

参数的顺序不同

注意：

一般构造方法都会进行重载（一个类中可能包含多个属性值，当只需要给部分属性初始化的时候需要调用不同的构造方法）



### 继承：

   表示父类跟子类之间的关系
   当两个类或者多个类具备相同的属性和方法的时候，可以提取出来，变成	父类，子类可以继承

   子类跟父类是is-a的关系

   使用：
      -1、使用继承的时候需要使用extend关键字
       2、使用继承关系之后，超类中的属性和方法都可以在子类中进行使用(**非私有属性和非私有方法)**
       3、java中是单继承关系(如果包含多个父类，同时父类中包含重名方法，无法决定改调用谁)

### super

是 直接父类 对象的引用
   用途：
       1、可以在子类中调用父类中被子类覆盖的方法  super.父类方法			名称
       2、当super在普通方法中使用的话，可以任意位置编写
       3、当super在构造方法中使用的话，会调用父类的构造方法，一定			要将super放在第一行
       4、在构造方法中super关键字和this关键字不能同时出现
       5、父类中私有的属性和方法都不能被调用，包括构造方法
      -6、子类的构造方法中都会默认使用super关键字调用父类的无参构			造方法,因此在定义类的时候，无论自己是否自定义了
               其他构造方法，最好将无参构造方法写上
      -7、如果构造方法中显式的指定了super的构造方法，那么无参的			造方法就不会被调用,否则会调

   总结：
       1、在创建子类对象的时候一定会优先创建父类对象
       2、所有的java类都具备同一个老祖宗类，称之为Object，是所有类的根类

### 重写：

   必须要存在继承关系，当父类中的方法无法满足子类需求的时候可以选择	使用重写的方式
   注意：
      1、重写表示的是子类覆盖父类的方法，当覆盖之后，调用同样的方				法的时候会优先调用子类
       2、重写的方法名称，返回值类型，参数列表必须跟父类一直
       3、子类重写的方法不允许比父类的方法具备更小的访问权限
           父类      public     子类  public
           父类      protected     子类  public 													protected
           父类      protected     子类  public 											protected  default
                    private 无法被继承
   父类的静态方法子类可以进行调用，但是子类不可以重写

### 抽象类：

*       1、创建抽象类的时候需要添加 abstract 的关键字
*       2、不能进行实例化，也就是不能new对象
*       3、抽象类中的某些方法需要子类进行更丰富的实现，父类实现没有意义，此时可以将抽象类
*       中的方法定义为抽象方法，没有具体的实现，只包含方法名称，返回值，参数列表，访问修饰符
*       4、使用abstract关键字修饰的方法叫做抽象方法，可以不写方法的实现
*       5、子类在继承抽象父类的时候，必须要将父类中的抽象方法进行实现或者将子类也定义为抽象类
*       6、有抽象方法的一定是抽象类，但是抽象类中不一定包含抽象方法

final

### 0bject

---

##### equals()

​	比较内容是否一致



### 多态

---

##### 规范(多态实现的提前)：

* 1、必须要有继承关系

*       2、子类方法必须重写父类的方法
*       3、父类引用指向子类对象

##### 多态的两种表现形式：

*   1、父类作为方法的参数
*   2、父类作为方法的返回值类型







~~~java
public void feed(Pet pet){
    pet.feed();
}

  public Pet buyPet(String type){
        if(type.equals("dog")){
            return new Dog();
        }else if(type.equals("cat")){
            return new Cat();
        }else{
            return new Penguin();
        }
    }

    Pet pet = p.buyPet("dog");//等价于 Pet pet = new dog();
	if(pet instanceof Dog){
            System.out.println("买的是一只狗");
        }else{
            System.out.println("买的是一只企鹅");
        }
~~~





​	



