![jvm](E:\deng\image\jvm\jvm.png)

类加载器

​	加载class文件

## 双亲委派机制

1.class loader收到类加载的请求，向上委托给父类加载器完成，直到boot

application --> extension --> bootStrap

如果上面两个都没有此类才会执行application的

### 什么是双亲委派机制

当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。

### 类加载器的类别

#### BootstrapClassLoader（启动类加载器）

`c++`编写，加载`java`核心库 `java.*`,构造`ExtClassLoader`和`AppClassLoader`。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作

#### ExtClassLoader （标准扩展类加载器）

`java`编写，加载扩展库，如`classpath`中的`jre` ，`javax.*`或者
 `java.ext.dir` 指定位置中的类，开发者可以直接使用标准扩展类加载器。

#### AppClassLoader（系统类加载器）

```
java`编写，加载程序所在的目录，如`user.dir`所在的位置的`class
```

#### CustomClassLoader（用户自定义类加载器）

`java`编写,用户自定义的类加载器,可加载指定路径的`class`文件

![img](https://upload-images.jianshu.io/upload_images/7634245-7b7882e1f4ea5d7d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

### 双亲委派机制的作用

1、防止重复加载同一个`.class`。通过委托去向上面问一问，加载过了，就不用再 加载一遍。保证数据安全。
 2、保证核心`.class`不能被篡改。通过委托方式，不会去篡改核心`.clas`，即使篡改也不会去加载，即使加载也不会是同一个`.class`对象了。不同的加载器加载同一个`.class`也不是同一个`Class`对象。这样保证了`Class`执行安全。



## 沙箱安全机制

凡带了native关键字的，说明超过了java的作用范围，会去调用底层C语言的库。

进入本地方法栈，调用JNI

JNI作用：扩展java使用，融合不同编程语言为java所用

诞生之初是为了在C、C++的环境下立足。

## 方法区

Method Area方法区
方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间；

**静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关**
static final，Class，常量池

## 栈

数据结构

栈内存，主管程序的运行，生命周期和线程同步

线程结束，也就是栈内存释放，对于栈来说，不存在垃圾回收问题

栈内：八大基本类型+对象引用+实例方法

![栈](E:\deng\image\jvm\栈.png)

## 堆

堆里的是方法引用，常量池分为静态常量池和运行时常量池，方法区里的是静态常量池，堆里的是运行时常量池（查的资料）

堆内存细分为三个区域

* 新生区
  * 
* 老年区
* 永久区
  * 1.6前：永久代，常量池在方法区
  * 1.7    ：永久区，但慢慢退化，`去永久代`，常量池在堆中
  * 1.8后：无永久代，常量池在元空间
  * 这个区域常驻内存的。用来存放DK自身携带的Class对象。Interface元数据，存储的是Java运行时的一些环境或类信息~，这个区域不存在垃圾回收！关闭VM虚拟就会释放这个区域的内存~



jdk8以后，永久存储区改为了元空间



OOM 堆内存满

-Xms：设置初始化内存分配大小 1/64

-Xms：设置最大分配内存，默认1/4

-XX:+PrintGCDetails 打印GC垃圾回收信息

-Xms8m -Xms8m -XX:+PrintGCDetails

​		1.尝试扩大内存看结果

-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError





## GC

分代收集算法

轻GC、重GC

### 引用计数法

占内存

### 复制算法

![复制算法](E:\deng\image\jvm\复制算法.png)



年轻代主要是用此算法

1.每次GC都会将Eden活的对象移到幸存区中的to区，同时将原来的from区复制到to区，然后剩下空的变成to区。

2.当一个对象经历了15次GC，都还没有死，进入养老区
-XX:-XX:MaxTenuring Threshold=9999通过这个参数可以设定进入老年代的次数

**好处**：没有内存碎片

**坏处**：浪费了一半的内存空间。

**应用场景**：对象存活度较低时，否则每次要从from复制大量的数据到to



### 标记清除

老年代用此

优点：无需额外空间

缺点：两次扫描，浪费时间，产生碎片

